---
layout:		post
title:		"æ·±å…¥ç†è§£Goä¹‹=="
subtitle: 	"æ·±å…¥ç»†èŠ‚ï¼Œç³»ç»Ÿä»‹ç»=="
# description: "æ•™ä½ å¦‚ä½•ä¸€æ­¥æ­¥åœ¨Windowsä¸Šå®‰è£…jekyllï¼Œå¸¸è§é—®é¢˜åŠè§£å†³"
date:		2019-08-20T12:57:00
author:		"darjun"
image:	"img/post-bg-2015.jpg"
tags:
    - æ·±å…¥ç†è§£Go
URL: "2019/08/20/golang-equal/"
categories: [ Tech ]
---

## æ¦‚è¿°
ç›¸ä¿¡`==`åˆ¤ç­‰æ“ä½œï¼Œå¤§å®¶æ¯å¤©éƒ½åœ¨ç”¨ã€‚ä¹‹å‰åœ¨è®ºå›ä¸Šçœ‹åˆ°ä¸å°‘äººåœ¨é—® golang `==`æ¯”è¾ƒçš„ç»“æœã€‚çœ‹åˆ°å¾ˆå¤šäººå¯¹ golang ä¸­`==`çš„ç»“æœä¸å¤ªäº†è§£ã€‚ç¡®å®ï¼Œgolang ä¸­å¯¹`==`çš„å¤„ç†æœ‰ä¸€äº›ç»†èŠ‚çš„åœ°æ–¹éœ€è¦ç‰¹åˆ«æ³¨æ„ã€‚è™½ç„¶å¹³æ—¶å¯èƒ½ä¸å¤ªä¼šé‡åˆ°ï¼Œä½†æ˜¯ç¢°åˆ°äº†å°±æ˜¯å¤§å‘ã€‚æœ¬æ–‡å°†å¯¹ golang ä¸­`==`æ“ä½œåšä¸€ä¸ªç³»ç»Ÿçš„ä»‹ç»ã€‚å¸Œæœ›èƒ½å¯¹å¤§å®¶æœ‰æ‰€å¸®åŠ©ã€‚

## ç±»å‹

golang ä¸­çš„æ•°æ®ç±»å‹å¯ä»¥åˆ†ä¸ºä»¥ä¸‹ 4 å¤§ç±»ï¼š
1. åŸºæœ¬ç±»å‹ï¼šæ•´å‹ï¼ˆ`int/uint/int8/uint8/int16/uint16/int32/uint32/int64/uint64/byte/rune`ç­‰ï¼‰ã€æµ®ç‚¹æ•°ï¼ˆ`float32/float64`ï¼‰ã€å¤æ•°ç±»å‹ï¼ˆ`complex64/complex128`ï¼‰ã€å­—ç¬¦ä¸²ï¼ˆ`string`ï¼‰ã€‚
2. å¤åˆç±»å‹ï¼ˆåˆå«èšåˆç±»å‹ï¼‰ï¼šæ•°ç»„å’Œç»“æ„ä½“ç±»å‹ã€‚
3. å¼•ç”¨ç±»å‹ï¼šåˆ‡ç‰‡ï¼ˆsliceï¼‰ã€mapã€channelã€æŒ‡é’ˆã€‚
4. æ¥å£ç±»å‹ï¼šå¦‚`error`ã€‚

**`==`æ“ä½œæœ€é‡è¦çš„ä¸€ä¸ªå‰ææ˜¯ï¼šä¸¤ä¸ªæ“ä½œæ•°ç±»å‹å¿…é¡»ç›¸åŒï¼ç±»å‹å¿…é¡»ç›¸åŒï¼ç±»å‹å¿…é¡»ç›¸åŒï¼**

å¦‚æœç±»å‹ä¸åŒï¼Œé‚£ä¹ˆ**ç¼–è¯‘æ—¶**å°±ä¼šæŠ¥é”™ã€‚

æ³¨æ„ï¼š
1. golang çš„ç±»å‹ç³»ç»Ÿéå¸¸ä¸¥æ ¼ï¼Œæ²¡æœ‰`C/C++`ä¸­çš„éšå¼ç±»å‹è½¬æ¢ã€‚è™½ç„¶å†™èµ·æ¥ç¨å¾®æœ‰äº›éº»çƒ¦ï¼Œä½†æ˜¯èƒ½é¿å…ä»Šåéå¸¸å¤šçš„éº»çƒ¦ï¼ï¼ï¼
2. golang ä¸­å¯ä»¥é€šè¿‡`type`å®šä¹‰æ–°ç±»å‹ã€‚æ–°å®šä¹‰çš„ç±»å‹ä¸åº•å±‚ç±»å‹ä¸åŒï¼Œä¸èƒ½ç›´æ¥æ¯”è¾ƒã€‚

**ä¸ºäº†æ›´å®¹æ˜“çœ‹å‡ºç±»å‹ï¼Œç¤ºä¾‹ä»£ç ä¸­çš„å˜é‡å®šä¹‰éƒ½æ˜¾å¼æŒ‡å®šäº†ç±»å‹ã€‚**

çœ‹ä¸‹é¢çš„ä»£ç ï¼š

```
package main

import "fmt"

func main() {
    var a int8
    var b int16
    // ç¼–è¯‘é”™è¯¯ï¼šinvalid operation a == b (mismatched types int8 and int16)
    fmt.Println(a == b)
}
```

**æ²¡æœ‰éšå¼ç±»å‹è½¬æ¢ã€‚**

```
package main

import "fmt"

func main() {
    type int8 myint8
    var a int8
    var b myint8
    // ç¼–è¯‘é”™è¯¯ï¼šinvalid operation a == b (mismatched types int8 and myint8)
    fmt.Println(a == b)
}
```

**è™½ç„¶myint8çš„åº•å±‚ç±»å‹æ˜¯int8ï¼Œä½†æ˜¯ä»–ä»¬æ˜¯ä¸åŒçš„ç±»å‹ã€‚**

ä¸‹é¢ä¾æ¬¡é€šè¿‡è¿™ 4 ç§ç±»å‹æ¥è¯´æ˜`==`æ˜¯å¦‚ä½•åšæ¯”è¾ƒçš„ã€‚

### åŸºæœ¬ç±»å‹

è¿™æ˜¯æœ€ç®€å•çš„ä¸€ç§ç±»å‹ã€‚æ¯”è¾ƒæ“ä½œä¹Ÿå¾ˆç®€å•ï¼Œç›´æ¥æ¯”è¾ƒå€¼æ˜¯å¦ç›¸ç­‰ã€‚æ²¡å•¥å¥½è¯´çš„ï¼Œç›´æ¥çœ‹ä¾‹å­ã€‚

```
var a uint32 = 10
var b uint32 = 20
var c uint32 = 10
fmt.Println(a == b) // false
fmt.Println(a == c) // true
```

æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œæµ®ç‚¹æ•°çš„æ¯”è¾ƒé—®é¢˜ï¼š

```
var a float64 = 0.1
var b float64 = 0.2
var c float64 = 0.3
fmt.Println(a + b == c) // false
```

å› ä¸ºè®¡ç®—æœºä¸­ï¼Œæœ‰äº›æµ®ç‚¹æ•°ä¸èƒ½ç²¾ç¡®è¡¨ç¤ºï¼Œæµ®ç‚¹è¿ç®—ç»“æœä¼šæœ‰è¯¯å·®ã€‚å¦‚æœæˆ‘ä»¬åˆ†åˆ«è¾“å‡º`a+b`å’Œ`c`çš„å€¼ï¼Œä¼šå‘ç°å®ƒä»¬ç¡®å®æ˜¯ä¸åŒçš„ï¼š

```
fmt.Println(a + b)
fmt.Println(c)

// 0.30000000000000004
// 0.3
```

è¿™ä¸ªé—®é¢˜ä¸æ˜¯ golang ç‹¬æœ‰çš„ï¼Œåªè¦æµ®ç‚¹æ•°éµå¾ª IEEE 754 æ ‡å‡†çš„ç¼–ç¨‹è¯­è¨€éƒ½æœ‰è¿™ä¸ªé—®é¢˜ã€‚éœ€è¦ç‰¹åˆ«æ³¨æ„ï¼Œ**å°½é‡ä¸è¦åšæµ®ç‚¹æ•°æ¯”è¾ƒï¼Œç¡®å®éœ€è¦æ¯”è¾ƒæ—¶ï¼Œè®¡ç®—ä¸¤ä¸ªæµ®ç‚¹æ•°çš„å·®çš„ç»å¯¹å€¼ï¼Œå¦‚æœå°äºä¸€å®šçš„å€¼å°±è®¤ä¸ºå®ƒä»¬ç›¸ç­‰ï¼Œæ¯”å¦‚`1e-9`**ã€‚

### å¤åˆç±»å‹

å¤åˆç±»å‹ä¹Ÿå«åšèšåˆç±»å‹ã€‚golang ä¸­çš„å¤åˆç±»å‹åªæœ‰ä¸¤ç§ï¼šæ•°ç»„å’Œç»“æ„ä½“ã€‚å®ƒä»¬æ˜¯é€å…ƒç´ /å­—æ®µæ¯”è¾ƒçš„ã€‚

æ³¨æ„ï¼š**æ•°ç»„çš„é•¿åº¦è§†ä¸ºç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œé•¿åº¦ä¸åŒçš„ä¸¤ä¸ªæ•°ç»„æ˜¯ä¸åŒçš„ç±»å‹ï¼Œä¸èƒ½ç›´æ¥æ¯”è¾ƒ**ã€‚

* å¯¹äºæ•°ç»„æ¥è¯´ï¼Œä¾æ¬¡æ¯”è¾ƒå„ä¸ª**å…ƒç´ **çš„å€¼ã€‚æ ¹æ®å…ƒç´ ç±»å‹çš„ä¸åŒï¼Œå†ä¾æ®æ˜¯åŸºæœ¬ç±»å‹ã€å¤åˆç±»å‹ã€å¼•ç”¨ç±»å‹æˆ–æ¥å£ç±»å‹ï¼ŒæŒ‰ç…§ç‰¹å®šç±»å‹çš„è§„åˆ™è¿›è¡Œæ¯”è¾ƒã€‚æ‰€æœ‰å…ƒç´ å…¨éƒ½ç›¸ç­‰ï¼Œæ•°ç»„æ‰æ˜¯ç›¸ç­‰çš„ã€‚
* å¯¹äºç»“æ„ä½“æ¥è¯´ï¼Œä¾æ¬¡æ¯”è¾ƒå„ä¸ª**å­—æ®µ**çš„å€¼ã€‚æ ¹æ®å­—æ®µç±»å‹çš„ä¸åŒï¼Œå†ä¾æ®æ˜¯ 4 ä¸­ç±»å‹ä¸­çš„å“ªä¸€ç§ï¼ŒæŒ‰ç…§ç‰¹å®šç±»å‹çš„è§„åˆ™è¿›è¡Œæ¯”è¾ƒã€‚æ‰€æœ‰å­—æ®µå…¨éƒ½ç›¸ç­‰ï¼Œç»“æ„ä½“æ‰æ˜¯ç›¸ç­‰çš„ã€‚

ä¾‹å¦‚ï¼š

```
a := [4]int{1, 2, 3, 4}
b := [4]int{1, 2, 3, 4}
c := [4]int{1, 3, 4, 5}
fmt.Println(a == b) // true
fmt.Println(a == c) // false

type A struct {
    a int
    b string
}
aa := A { a : 1, b : "test1" }
bb := A { a : 1, b : "test1" }
cc := A { a : 1, b : "test2" }
fmt.Println(aa == bb)
fmt.Println(aa == cc)
```

### å¼•ç”¨ç±»å‹

å¼•ç”¨ç±»å‹æ˜¯é—´æ¥æŒ‡å‘å®ƒæ‰€å¼•ç”¨çš„æ•°æ®çš„ï¼Œä¿å­˜çš„æ˜¯æ•°æ®çš„åœ°å€ã€‚**å¼•ç”¨ç±»å‹çš„æ¯”è¾ƒå®é™…åˆ¤æ–­çš„æ˜¯ä¸¤ä¸ªå˜é‡æ˜¯ä¸æ˜¯æŒ‡å‘åŒä¸€ä»½æ•°æ®ï¼Œå®ƒä¸ä¼šå»æ¯”è¾ƒå®é™…æŒ‡å‘çš„æ•°æ®ã€‚**

ä¾‹å¦‚ï¼š

```
type A struct {
    a int
    b string
}

aa := &A { a : 1, b : "test1" }
bb := &A { a : 1, b : "test1" }
cc := aa
fmt.Println(aa == bb)
fmt.Println(aa == cc)
```

å› ä¸º`aa`å’Œ`bb`æŒ‡å‘çš„ä¸¤ä¸ªä¸åŒçš„ç»“æ„ä½“ï¼Œè™½ç„¶å®ƒä»¬æŒ‡å‘çš„å€¼æ˜¯ç›¸ç­‰çš„ï¼ˆè§ä¸Šé¢å¤åˆç±»å‹çš„æ¯”è¾ƒï¼‰ï¼Œä½†æ˜¯å®ƒä»¬ä¸ç­‰ã€‚
`aa`å’Œ`cc`æŒ‡å‘ç›¸åŒçš„ç»“æ„ä½“ï¼Œæ‰€ä»¥å®ƒä»¬ç›¸ç­‰ã€‚

å†çœ‹çœ‹`channel`çš„æ¯”è¾ƒï¼š

```
ch1 := make(chan int, 1)
ch2 := make(chan int, 1)
ch3 := ch1

fmt.Println(ch1 == ch2)
fmt.Println(ch1 == ch3)
```

`ch1`å’Œ`ch2`è™½ç„¶ç±»å‹ç›¸åŒï¼Œä½†æ˜¯æŒ‡å‘ä¸åŒçš„`channel`ï¼Œæ‰€ä»¥å®ƒä»¬ä¸ç­‰ã€‚
`ch1`å’Œ`ch3`æŒ‡å‘ç›¸åŒçš„`channel`ï¼Œæ‰€ä»¥å®ƒä»¬ç›¸ç­‰ã€‚

å…³äºå¼•ç”¨ç±»å‹ï¼Œæœ‰ä¸¤ä¸ªæ¯”è¾ƒç‰¹æ®Šçš„è§„å®šï¼š
* åˆ‡ç‰‡ä¹‹é—´ä¸å…è®¸æ¯”è¾ƒã€‚åˆ‡ç‰‡åªèƒ½ä¸`nil`å€¼æ¯”è¾ƒã€‚
* `map`ä¹‹é—´ä¸å…è®¸æ¯”è¾ƒã€‚`map`åªèƒ½ä¸`nil`å€¼æ¯”è¾ƒã€‚

ä¸ºä»€ä¹ˆè¦åšè¿™æ ·çš„è§„å®šï¼Ÿæˆ‘ä»¬å…ˆæ¥è¯´åˆ‡ç‰‡ã€‚å› ä¸ºåˆ‡ç‰‡æ˜¯å¼•ç”¨ç±»å‹ï¼Œå®ƒå¯ä»¥é—´æ¥çš„æŒ‡å‘è‡ªå·±ã€‚ä¾‹å¦‚ï¼š

```
a := []interface{}{ 1, 2.0 }
a[1] = a
fmt.Println(a)

// !!!
// runtime: goroutine stack exceeds 1000000000-byte limit
// fatal error: stack overflow
```

ä¸Šé¢ä»£ç å°†`a`èµ‹å€¼ç»™`a[1]`å¯¼è‡´é€’å½’å¼•ç”¨ï¼Œ`fmt.Println(a)`è¯­å¥ç›´æ¥çˆ†æ ˆã€‚

* åˆ‡ç‰‡å¦‚æœç›´æ¥æ¯”è¾ƒå¼•ç”¨åœ°å€ï¼Œæ˜¯ä¸åˆé€‚çš„ã€‚é¦–å…ˆï¼Œåˆ‡ç‰‡ä¸æ•°ç»„æ˜¯æ¯”è¾ƒç›¸è¿‘çš„ç±»å‹ï¼Œæ¯”è¾ƒæ–¹å¼çš„å·®å¼‚ä¼šé€ æˆä½¿ç”¨è€…çš„æ··æ·†ã€‚å¦å¤–ï¼Œé•¿åº¦å’Œå®¹é‡æ˜¯åˆ‡ç‰‡ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œä¸åŒé•¿åº¦å’Œå®¹é‡çš„åˆ‡ç‰‡å¦‚ä½•æ¯”è¾ƒï¼Ÿ
* åˆ‡ç‰‡å¦‚æœåƒæ•°ç»„é‚£æ ·æ¯”è¾ƒé‡Œé¢çš„å…ƒç´ ï¼Œåˆä¼šå‡ºç°ä¸Šæ¥æåˆ°çš„å¾ªç¯å¼•ç”¨çš„é—®é¢˜ã€‚è™½ç„¶å¯ä»¥åœ¨è¯­è¨€å±‚é¢è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯ golang å›¢é˜Ÿè®¤ä¸ºä¸å€¼å¾—ä¸ºæ­¤è€—è´¹ç²¾åŠ›ã€‚

åŸºäºä¸Šé¢ä¸¤ç‚¹åŸå› ï¼Œgolang ç›´æ¥è§„å®š**åˆ‡ç‰‡ç±»å‹ä¸å¯æ¯”è¾ƒ**ã€‚ä½¿ç”¨`==`æ¯”è¾ƒåˆ‡ç‰‡ç›´æ¥ç¼–è¯‘æŠ¥é”™ã€‚

ä¾‹å¦‚ï¼š

```
var a []int
var b []int

// invalid operation: a == b (slice can only be compared to nil)
fmt.Println(a == b)
```

é”™è¯¯ä¿¡æ¯å¾ˆæ˜ç¡®ã€‚

**å› ä¸º`map`çš„å€¼ç±»å‹å¯èƒ½ä¸ºä¸å¯æ¯”è¾ƒç±»å‹ï¼ˆè§ä¸‹é¢ï¼Œåˆ‡ç‰‡æ˜¯ä¸å¯æ¯”è¾ƒç±»å‹ï¼‰ï¼Œæ‰€ä»¥`map`ç±»å‹ä¹Ÿä¸å¯æ¯”è¾ƒğŸ¤£ã€‚**

### æ¥å£ç±»å‹

æ¥å£ç±»å‹æ˜¯ golang ä¸­æ¯”è¾ƒé‡è¦çš„ä¸€ç§ç±»å‹ã€‚æ¥å£ç±»å‹çš„å€¼ï¼Œæˆ‘ä»¬ç§°ä¸ºæ¥å£å€¼ã€‚ä¸€ä¸ªæ¥å£å€¼æ˜¯ç”±ä¸¤ä¸ªéƒ¨åˆ†ç»„æˆçš„ï¼Œå…·ä½“ç±»å‹ï¼ˆå³è¯¥æ¥å£å­˜å‚¨çš„å€¼çš„ç±»å‹ï¼‰å’Œè¯¥ç±»å‹çš„ä¸€ä¸ªå€¼ã€‚å¼•ç”¨ã€Šgo ç¨‹åºè®¾è®¡è¯­è¨€ã€‹çš„åç§°ï¼Œåˆ†åˆ«ç§°ä¸º**åŠ¨æ€ç±»å‹**å’Œ**åŠ¨æ€å€¼**ã€‚æ¥å£å€¼çš„æ¯”è¾ƒæ¶‰åŠè¿™ä¸¤éƒ¨åˆ†çš„æ¯”è¾ƒï¼Œåªæœ‰å½“**åŠ¨æ€ç±»å‹å®Œå…¨ç›¸åŒ**ä¸”åŠ¨æ€å€¼ç›¸ç­‰ï¼ˆåŠ¨æ€å€¼ä½¿ç”¨`==`æ¯”è¾ƒï¼‰ï¼Œä¸¤ä¸ªæ¥å£å€¼æ‰æ˜¯ç›¸ç­‰çš„ã€‚

ä¾‹å¦‚ï¼š

```
var a interface{} = 1
var b interface{} = 2
var c interface{} = 1
var d interface{} = 1.0
fmt.Println(a == b) // false
fmt.Println(a == c) // true
fmt.Println(a == d) // false
```

`a`å’Œ`b`åŠ¨æ€ç±»å‹ç›¸åŒï¼ˆéƒ½æ˜¯`int`ï¼‰ï¼ŒåŠ¨æ€å€¼ä¹Ÿç›¸åŒï¼ˆéƒ½æ˜¯`1`ï¼ŒåŸºæœ¬ç±»å‹æ¯”è¾ƒï¼‰ï¼Œæ•…ä¸¤è€…ç›¸ç­‰ã€‚
`a`å’Œ`c`åŠ¨æ€ç±»å‹ç›¸åŒï¼ŒåŠ¨æ€å€¼ä¸ç­‰ï¼ˆåˆ†åˆ«ä¸º`1`å’Œ`2`ï¼ŒåŸºæœ¬ç±»å‹æ¯”è¾ƒï¼‰ï¼Œæ•…ä¸¤è€…ä¸ç­‰ã€‚
`a`å’Œ`d`åŠ¨æ€ç±»å‹ä¸åŒï¼Œ`a`ä¸º`int`ï¼Œ`d`ä¸º`float64`ï¼Œæ•…ä¸¤è€…ä¸ç­‰ã€‚

```
type A struct {
    a int
    b string
}

var aa interface{} = A { a: 1, b: "test" }
var bb interface{} = A { a: 1, b: "test" }
var cc interface{} = A { a: 2, b: "test" }

fmt.Println(aa == bb) // true
fmt.Println(aa == cc) // false

var dd interface{} = &A { a: 1, b: "test" }
var ee interface{} = &A { a: 1, b: "test" }
fmt.Println(dd == ee) // false
```

`aa`å’Œ`bb`åŠ¨æ€ç±»å‹ç›¸åŒï¼ˆéƒ½æ˜¯`A`ï¼‰ï¼ŒåŠ¨æ€å€¼ä¹Ÿç›¸åŒï¼ˆç»“æ„ä½“`A`ï¼Œè§ä¸Šé¢å¤åˆç±»å‹çš„æ¯”è¾ƒè§„åˆ™ï¼‰ï¼Œæ•…ä¸¤è€…ç›¸ç­‰ã€‚
`aa`å’Œ`cc`åŠ¨æ€ç±»å‹ç›¸åŒï¼ŒåŠ¨æ€å€¼ä¸åŒï¼Œæ•…ä¸¤è€…ä¸ç­‰ã€‚
`dd`å’Œ`ee`åŠ¨æ€ç±»å‹ç›¸åŒï¼ˆéƒ½æ˜¯`*A`ï¼‰ï¼ŒåŠ¨æ€å€¼ä½¿ç”¨æŒ‡é’ˆï¼ˆå¼•ç”¨ï¼‰ç±»å‹çš„æ¯”è¾ƒï¼Œç”±äºä¸æ˜¯æŒ‡å‘åŒä¸€ä¸ªåœ°å€ï¼Œæ•…ä¸ç­‰ã€‚

æ³¨æ„ï¼š

**å¦‚æœæ¥å£çš„åŠ¨æ€å€¼ä¸å¯æ¯”è¾ƒï¼Œå¼ºè¡Œæ¯”è¾ƒä¼š`panic`ï¼ï¼ï¼**

```
var a interface{} = []int{1, 2, 3, 4}
var b interface{} = []int{1, 2, 3, 4}
// panic: runtime error: comparing uncomparable type []int
fmt.Println(a == b)
```

`a`å’Œ`b`çš„åŠ¨æ€å€¼æ˜¯åˆ‡ç‰‡ç±»å‹ï¼Œè€Œåˆ‡ç‰‡ç±»å‹ä¸å¯æ¯”è¾ƒï¼Œæ‰€ä»¥`a == b`ä¼š`panic`ã€‚

**æ¥å£å€¼çš„æ¯”è¾ƒä¸è¦æ±‚æ¥å£ç±»å‹ï¼ˆæ³¨æ„ä¸æ˜¯åŠ¨æ€ç±»å‹ï¼‰å®Œå…¨ç›¸åŒï¼Œåªè¦ä¸€ä¸ªæ¥å£å¯ä»¥è½¬åŒ–ä¸ºå¦ä¸€ä¸ªå°±å¯ä»¥æ¯”è¾ƒ**ã€‚ä¾‹å¦‚ï¼š

```
var f *os.File

var r io.Reader = f
var rc io.ReadCloser = f
fmt.Println(r == rc) // true

var w io.Writer = f
// invalid operation: r == w (mismatched types io.Reader and io.Writer)
fmt.Println(r == w)
```

`r`çš„ç±»å‹ä¸º`io.Reader`æ¥å£ï¼Œ`rc`çš„ç±»å‹ä¸º`io.ReadCloser`æ¥å£ã€‚æŸ¥çœ‹æºç ï¼Œ`io.ReadCloser`çš„å®šä¹‰å¦‚ä¸‹ï¼š

```
type ReadCloser interface {
	Reader
	Closer
}
```

`io.ReadCloser`å¯è½¬åŒ–ä¸º`io.Reader`ï¼Œæ•…ä¸¤è€…å¯æ¯”è¾ƒã€‚

è€Œ`io.Writer`ä¸å¯è½¬åŒ–ä¸º`io.Reader`ï¼Œç¼–è¯‘æŠ¥é”™ã€‚

### ä½¿ç”¨`type`å®šä¹‰çš„ç±»å‹

ä½¿ç”¨`type`å¯ä»¥åŸºäºç°æœ‰ç±»å‹å®šä¹‰æ–°çš„ç±»å‹ã€‚æ–°ç±»å‹ä¼šæ ¹æ®å®ƒä»¬çš„åº•å±‚ç±»å‹æ¥æ¯”è¾ƒã€‚ä¾‹å¦‚ï¼š

```
type myint int
var a myint = 10
var b myint = 20
var c myint = 10
fmt.Println(a == b) // false
fmt.Println(a == c) // true

type arr4 [4]int
var aa arr4 = [4]int{1, 2, 3, 4}
var bb arr4 = [4]int{1, 2, 3, 4}
var cc arr4 = [4]int{1, 2, 3, 5}
fmt.Println(aa == bb)
fmt.Println(aa == cc)
```

`myint`æ ¹æ®åº•å±‚ç±»å‹`int`æ¥æ¯”è¾ƒã€‚
`arr4`æ ¹æ®åº•å±‚ç±»å‹`[4]int`æ¥æ¯”è¾ƒã€‚

## ä¸å¯æ¯”è¾ƒæ€§

å‰é¢è¯´è¿‡ï¼Œgolang ä¸­çš„åˆ‡ç‰‡ç±»å‹æ˜¯ä¸å¯æ¯”è¾ƒçš„ã€‚æ‰€æœ‰å«æœ‰åˆ‡ç‰‡çš„ç±»å‹éƒ½æ˜¯ä¸å¯æ¯”è¾ƒçš„ã€‚ä¾‹å¦‚ï¼š

* æ•°ç»„å…ƒç´ æ˜¯åˆ‡ç‰‡ç±»å‹ã€‚
* ç»“æ„ä½“æœ‰åˆ‡ç‰‡ç±»å‹çš„å­—æ®µã€‚
* æŒ‡é’ˆæŒ‡å‘çš„æ˜¯åˆ‡ç‰‡ç±»å‹ã€‚

**ä¸å¯æ¯”è¾ƒæ€§ä¼šä¼ é€’ï¼Œå¦‚æœä¸€ä¸ªç»“æ„ä½“ç”±äºå«æœ‰åˆ‡ç‰‡å­—æ®µä¸å¯æ¯”è¾ƒï¼Œé‚£ä¹ˆå°†å®ƒä½œä¸ºå…ƒç´ çš„æ•°ç»„ä¸å¯æ¯”è¾ƒï¼Œå°†å®ƒä½œä¸ºå­—æ®µç±»å‹çš„ç»“æ„ä½“ä¸å¯æ¯”è¾ƒ**ã€‚

## è°ˆè°ˆ`map`

ç”±äº`map`çš„`key`æ˜¯ä½¿ç”¨`==`æ¥åˆ¤ç­‰çš„ï¼Œæ‰€ä»¥æ‰€æœ‰ä¸å¯æ¯”è¾ƒçš„ç±»å‹éƒ½ä¸èƒ½ä½œä¸º`map`çš„`key`ã€‚ä¾‹å¦‚ï¼š

```
// invalid map key type []int
m1 := make(map[[]int]int)

type A struct {
    a []int
    b string
}
// invalid map key type A
m2 := make(map[A]int)
```

ç”±äºåˆ‡ç‰‡ç±»å‹ä¸å¯æ¯”è¾ƒï¼Œä¸èƒ½ä½œä¸º`map`çš„`key`ï¼Œç¼–è¯‘æ—¶`m1 := make(map[[]int]int)`æŠ¥é”™ã€‚
ç”±äºç»“æ„ä½“`A`å«æœ‰åˆ‡ç‰‡å­—æ®µï¼Œä¸å¯æ¯”è¾ƒï¼Œä¸èƒ½ä½œä¸º`map`çš„`key`ï¼Œç¼–è¯‘æŠ¥é”™ã€‚

## æ€»ç»“

æœ¬æ–‡è¯¦å°½ä»‹ç»äº† golang ä¸­`==`æ“ä½œçš„ç»†èŠ‚ï¼Œå¸Œæœ›èƒ½å¯¹å¤§å®¶æœ‰æ‰€å¸®åŠ©ã€‚

## å‚è€ƒ

1. [Goç¨‹åºè®¾è®¡è¯­è¨€](https://book.douban.com/subject/27044219/)

[æˆ‘çš„ä¸ªäººä¸»é¡µ](https://darjun.github.io)